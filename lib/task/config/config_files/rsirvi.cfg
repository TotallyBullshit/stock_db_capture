# Copyright Â© Kevin P. Nolan 2009 All Rights Reserved.

require 'rpctypes'
extend Task::RPCTypes
#
# Encodings for Composite Types
#
type Position, :signature => PositionProxy do |proxy|
  if proxy.is_a?(Array)
    PositionProxy.dereference(proxy)
  else
    proxy.dereference
  end
end

type PositionProxy, :signature => Position do |position|
  position.to_proxy
end

type TimeseriesProxy, :signature => Timeseries do |timeseries|
  timeseries.to_proxy
end

type Timeseries, :signature => TimeseriesProxy do |proxy|
  if proxy.is_a?(Array)
    TimeseriesProxy.dereference(proxy)
  else
    proxy.dereference
  end
end

type Displacement, :signature => DisplacementProxy do |proxy|
  if proxy.is_a?(Array)
    DisplacementProxy.dereference(proxy)
  else
    proxy.dereference
  end
end

type DisplacementProxy, :signature => Displacement do |displacement|
  displacement.to_proxy
end

type :confirmation, :signature => [nil, Integer] do |flag|
  flag
end

#-----------------------------------------------------------------------------------------------------------------
# "Find all places where RSI gooes heads upwards of 30"
#------------------------------------------------------------------------------------------------------------------
task :rsi_trigger_14, :targets => [:open_rsi_rvi], :inputs => [Timeseries],
                      :outputs => [Position], :result_protocol => :yield,
                      :params => { :time_period => 14,:epass => 0..2, :result => [:rsi] } do |ts|
  task = self
  begin
    ts.logger = self.logger
    ent_id = Indicator.lookup(:rsi).id
    index_hash = { }
    for pass in params[:epass]
      position = nil
      ts.instance_exec(self, params, pass) do |task, params, pass|
        rsi_vec = rsi(params).first
        indexes = under_threshold(20+pass*5, rsi_vec)
        uniq_indexes = indexes.reject { |index| flag = index_hash[index]; index_hash[index] = true; flag }
        for index in uniq_indexes
          trigger_date, trigger_price = ts.closing_values_at(index)
          trigger_ival = ts.result_at(index, :rsi)
          position = Position.trigger_entry(ticker_id, trigger_date, trigger_price, ent_id, trigger_ival, pass)
          task.yield_value position
        end
      end
    end
  rescue TimeseriesException => e
    $stderr.puts "#{e.class} #{e.message}"
    position.destroy if position
  rescue ActiveRecord::StatementInvalid => e
    $stderr.puts "#{e.class} #{e.message}"
    position.destroy if position
  end
end

#-----------------------------------------------------------------------------------------------------------------
# Open all the positions generated by rsi_open_14
#------------------------------------------------------------------------------------------------------------------
task :open_rsi_rvi, :targets => [:rsi_rvi_50], :inputs => [Position], :outputs => [Position] do |position|
  position.open_using_trigger_values()
end

#-----------------------------------------------------------------------------------------------------------------
# "Find all datetimes where an RSI crosses 50 from below for the given position"
#------------------------------------------------------------------------------------------------------------------
task :rsi_rvi_50, :targets => [:exit_rsirvi], :inputs => [Position],
                  :outputs => [Position, Displacement], :wrapper => :displacement,
                  :params => { :start_date => :entry_date, :time_period => 14, :window => 20, :threshold => 50, :result => :gv } do |params, position|
  time, method = close_under_min(:rsi => params, :rvi => params)
  time = max_exit_date if time.nil?
  debugger if time.nil?
  [position, Displacement.new(time, value_at(time, :close), method, method.nil? ? nil : result_at(time, method))]
end

#-----------------------------------------------------------------------------------------------------------------
# Exit all positions that made it through the rsi_rvi_50 filter
#-----------------------------------------------------------------------------------------------------------------
task :exit_rsirvi, :targets => [:lagged_rsi_difference], :inputs => [Position, Displacement],
                                                         :outputs => [Position] do |position, displacement|
  position.trigger_exit(*displacement.to_a)
end

#-----------------------------------------------------------------------------------------------------------------
# "Close positions that have been triggered from an RVI or and RSI and whose indicatars have continued to climb until
# they peak out or level out"
#------------------------------------------------------------------------------------------------------------------
task :lagged_rsi_difference, :targets => [:rsirvi_close], :inputs => [Position],
                             :outputs => [Position, Displacement], :wrapper => :displacement,
                             :params => { :start_date => :xttime, :time_period => 14, :window => 10, :result => :gv } do |params, position|
    rsi_ary = rsi(params)
    subvec = rsi_ary.subvector(0, params[:window])
    diff_vec = subvec.diff()
    dn = diff_vec.to_a.index { |diff| diff <= 0.0 }
    index = dn.nil? ? params[:window] : dn
    time = rindex2time(index)
    [ position, Displacement.new(time, value_at(time, :close), :rsi, result_at(time, :rsi)) ]
end

#-----------------------------------------------------------------------------------------------------------------
# Close the positions after they have been optimized by the prior filter
#-----------------------------------------------------------------------------------------------------------------
task :rsirvi_close, :targets => [], :inputs => [Position, Displacement ], :outputs => [] do |position, displacement|
  position.close(*displacement.to_a)
end

#-----------------------------------------------------------------------------------------------------------------
# This task takes a scan_id, looks up the Scan record and the bundles a triple of args needed by a Timeseries
# Note that this task directly generates messages as fast as it can read ticker_ids from the DB
#-----------------------------------------------------------------------------------------------------------------
task :timeseries_args,  :inputs => [Integer], :targets => [:rsi_trigger_14 ], :outputs => [Timeseries],
                        :result_protocol => :yield do |scan_id|
  scan = Scan.find scan_id
  start_date = scan.start_date
  end_date = scan.end_date
  for ticker_id in scan.population_ids
    yield_value Timeseries.new(ticker_id, start_date..end_date, 1.day, :logger => self.logger)
  end
  Thread.current.exit
end

#-----------------------------------------------------------------------------------------------------------------
# Yield the primary key of the Scan record associated with this year
#-----------------------------------------------------------------------------------------------------------------
task :scan_gen, :targets => [:timeseries_args], :inputs => [], :outputs => [Integer], :result_protocol => :yield do
  for year in 2000..2009
    scan = Scan.find_by_year(year)
    yield_value scan.id
  end
  Thread.current.exit
end

global_options :generate_stats => false, :truncate => true, :repopulate => true, :log_flags => [:basic], :resolution => 1.day,
               :prefetch => Timeseries.prefetch_bars(:rsi, 14), :postfetch => 20, :populate => true, :verbose => false

post_process do
#  make_sheet([:opening, :close, :high, :low, :volume], :pre_days => 1, :post_days => 30, :keep => true)
end

# Local Variables:
# mode:ruby
# End:
