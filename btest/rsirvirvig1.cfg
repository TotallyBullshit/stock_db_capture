# Copyright Â© Kevin P. Nolan 2009 All Rights Reserved.

#-----------------------------------------------------------------------------------------------------------------
# "Find all places where RSI gooes heads upwards of 30"
#------------------------------------------------------------------------------------------------------------------
source :rsi_trigger_14, :time_period => 14,:epass => 0..2, :result => [:rsi], :outputs => [:rvig_confirm] do |params, pass|
  rsi_vec = rsi(params).first
  indexes = under_threshold(20+pass*5, rsi_vec)
end


#-----------------------------------------------------------------------------------------------------------------
# Only open thos positions where the slope of the rvigor is positve. This filters out rsi events on a downwardslope
#-----------------------------------------------------------------------------------------------------------------
filter :rvig_confirm, :outputs => [:open_rsi_rvi], :result => :first, :type => :confirm do |params, position|
  rvig = rvig(:result => :first)
  rvig.diff[(result_offset-1)..(result_offset+1]).all? { |el| el > 0.0 } ? adj_result_index(0) : nil
end

#-----------------------------------------------------------------------------------------------------------------
# Open all the positions generated by rsi_open_14
#------------------------------------------------------------------------------------------------------------------
open :open_rsi_rvi, :outputs => [:rsi_rvi_50_rvig] do |params, position|
  position.propegate_values_from(:rvig_confirm, params)
end

#-----------------------------------------------------------------------------------------------------------------
# exit trigger when the rsi or rvi goes above 50 or the rvigor is positive
#-----------------------------------------------------------------------------------------------------------------
 filter :rsi_rvi_50_rvig, :time_period => 14, :result => :first, :type => :displace do |params|
    min_time, meth = close_under_min(:rsi => params.merge(:threshold => 50),
                                     :rvi => params.merge(:threshold => 50))
    if min_time.nil?
      rvig = rvig(:result => :gv)
      index = over_threshold(0.0, rvig).first
      if index
        [index2time(index), :rvigor, result_at(index, :rvigor)]
      else
        [min_time, meth, result_at(min_time, meth)]
      end
    end
    [min_time, meth, result_at(min_time, meth)]
  end

#-----------------------------------------------------------------------------------------------------------------
# Exit all positions that made it through the rsi_rvi_50 filter
#-----------------------------------------------------------------------------------------------------------------
exit :exit_rsirvi, :outputs => [:gradient_ascent] do |params, position|
  position.propegate_values_from(:rsi_rvi_50_rvi, params)
end

#-----------------------------------------------------------------------------------------------------------------
# "Close positions that have been triggered from an RVI or and RSI and whose indicatars have continued to climb until
# they peak out or level out"
#------------------------------------------------------------------------------------------------------------------
filter:gradient_ascent, :outputs => [:rsirvirvig_close], :time_period => 14, :window => 10, :result => [:rsi] do |params, position|
  retunring [] do
    rsi_ary = rsi(params)
    rsi_ary2 = rsi_ary.dup
    rsi_ary.slice!(0, params[:window])
    rsi_dn = rsi_ary.diff().index { |diff| diff <= 0.0 }
    rsi_index = dn.nil? ? params[:window] : dn
    rsi_method = params[:result].irst
    rvig_ary = rvigor(:result => :first)
    rvig_ary2 = rsi_ary.duplicate
    rsig_ary.slice!(0, params[:window])
    rvig_dn = rvi_ary.diff().index { |diff| diff <= 0.0 }
    rvig_index = dn.nil? ? params[:window] : dn
    rvig_method = :rvigor
    [index, params[:result].first]
    case rsi_index <=> rvig_index
    when -1..0: [time2index(rsi_index), rsi_method, result_at(index, param[result].first)]
    else
      [time2index(rvig_index), :rvigor, result_at(index, :rvigor]]
     end
  end
end

#-----------------------------------------------------------------------------------------------------------------
# Close the positions after they have been optimized by the prior filter
#-----------------------------------------------------------------------------------------------------------------
close :rsirvirvig_close, :outputs => [] do |params, position|
  position.propegate_values_from(::gradient_ascent)
end



liquid = "min(volume) >= 75000"
(2000..2000).each do |year|
  start_date = Date.civil(year, 1, 1)
  scan_name = "year_#{year}".to_sym
  end_date = start_date + 1.year - 1.day
  scan scan_name, :start_date =>  start_date, :end_date => end_date,
                  :conditions => liquid, :prefetch => Timeseries.prefetch_bars(:rsi, 14),
                  :join => 'LEFT OUTER JOIN tickers ON tickers.id = ticker_id',
                  :order_by => 'tickers.symbol', :outputs => [:rsi_trigger_14 ]
end

global_options :generate_stats => false, :truncate => :scan, :repopulate => true, :log_flags => [:basic],
               :prefetch => Timeseries.prefetch_bars(:rsi, 14), :postfetch => 20, :populate => true

post_process do
#  make_sheet([:opening, :close, :high, :low, :volume], :pre_days => 1, :post_days => 30, :keep => true)
end

# Local Variables:
# mode:ruby
# End:
